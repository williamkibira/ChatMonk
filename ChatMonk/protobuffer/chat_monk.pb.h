// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat_monk.proto

#ifndef PROTOBUF_chat_5fmonk_2eproto__INCLUDED
#define PROTOBUF_chat_5fmonk_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace protobuffer {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_chat_5fmonk_2eproto();
void protobuf_AssignDesc_chat_5fmonk_2eproto();
void protobuf_ShutdownFile_chat_5fmonk_2eproto();

class FriendDef;
class RegistrationPack;
class GroupRegistration;
class GroupDef;
class Attachment;
class Message;
class InvitationOut;
class InvitationDef;

enum Message_MessageType {
  Message_MessageType_GRP_MSG = 0,
  Message_MessageType_FRND_MSG = 1
};
bool Message_MessageType_IsValid(int value);
const Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_GRP_MSG;
const Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_FRND_MSG;
const int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

// ===================================================================

class FriendDef : public ::google::protobuf::MessageLite {
 public:
  FriendDef();
  virtual ~FriendDef();

  FriendDef(const FriendDef& from);

  inline FriendDef& operator=(const FriendDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const FriendDef& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FriendDef* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FriendDef* other);

  // implements Message ----------------------------------------------

  FriendDef* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FriendDef& from);
  void MergeFrom(const FriendDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string first_name = 1;
  inline bool has_first_name() const;
  inline void clear_first_name();
  static const int kFirstNameFieldNumber = 1;
  inline const ::std::string& first_name() const;
  inline void set_first_name(const ::std::string& value);
  inline void set_first_name(const char* value);
  inline void set_first_name(const char* value, size_t size);
  inline ::std::string* mutable_first_name();
  inline ::std::string* release_first_name();
  inline void set_allocated_first_name(::std::string* first_name);

  // optional string last_name = 2;
  inline bool has_last_name() const;
  inline void clear_last_name();
  static const int kLastNameFieldNumber = 2;
  inline const ::std::string& last_name() const;
  inline void set_last_name(const ::std::string& value);
  inline void set_last_name(const char* value);
  inline void set_last_name(const char* value, size_t size);
  inline ::std::string* mutable_last_name();
  inline ::std::string* release_last_name();
  inline void set_allocated_last_name(::std::string* last_name);

  // optional string phone_number = 3;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 3;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const char* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string friend_id = 5;
  inline bool has_friend_id() const;
  inline void clear_friend_id();
  static const int kFriendIdFieldNumber = 5;
  inline const ::std::string& friend_id() const;
  inline void set_friend_id(const ::std::string& value);
  inline void set_friend_id(const char* value);
  inline void set_friend_id(const char* value, size_t size);
  inline ::std::string* mutable_friend_id();
  inline ::std::string* release_friend_id();
  inline void set_allocated_friend_id(::std::string* friend_id);

  // optional string photo_uri = 6;
  inline bool has_photo_uri() const;
  inline void clear_photo_uri();
  static const int kPhotoUriFieldNumber = 6;
  inline const ::std::string& photo_uri() const;
  inline void set_photo_uri(const ::std::string& value);
  inline void set_photo_uri(const char* value);
  inline void set_photo_uri(const char* value, size_t size);
  inline ::std::string* mutable_photo_uri();
  inline ::std::string* release_photo_uri();
  inline void set_allocated_photo_uri(::std::string* photo_uri);

  // @@protoc_insertion_point(class_scope:protobuffer.FriendDef)
 private:
  inline void set_has_first_name();
  inline void clear_has_first_name();
  inline void set_has_last_name();
  inline void clear_has_last_name();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_friend_id();
  inline void clear_has_friend_id();
  inline void set_has_photo_uri();
  inline void clear_has_photo_uri();

  ::std::string* first_name_;
  ::std::string* last_name_;
  ::std::string* phone_number_;
  ::std::string* email_;
  ::std::string* friend_id_;
  ::std::string* photo_uri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static FriendDef* default_instance_;
};
// -------------------------------------------------------------------

class RegistrationPack : public ::google::protobuf::MessageLite {
 public:
  RegistrationPack();
  virtual ~RegistrationPack();

  RegistrationPack(const RegistrationPack& from);

  inline RegistrationPack& operator=(const RegistrationPack& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistrationPack& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistrationPack* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistrationPack* other);

  // implements Message ----------------------------------------------

  RegistrationPack* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistrationPack& from);
  void MergeFrom(const RegistrationPack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string first_name = 1;
  inline bool has_first_name() const;
  inline void clear_first_name();
  static const int kFirstNameFieldNumber = 1;
  inline const ::std::string& first_name() const;
  inline void set_first_name(const ::std::string& value);
  inline void set_first_name(const char* value);
  inline void set_first_name(const char* value, size_t size);
  inline ::std::string* mutable_first_name();
  inline ::std::string* release_first_name();
  inline void set_allocated_first_name(::std::string* first_name);

  // required string last_name = 2;
  inline bool has_last_name() const;
  inline void clear_last_name();
  static const int kLastNameFieldNumber = 2;
  inline const ::std::string& last_name() const;
  inline void set_last_name(const ::std::string& value);
  inline void set_last_name(const char* value);
  inline void set_last_name(const char* value, size_t size);
  inline ::std::string* mutable_last_name();
  inline ::std::string* release_last_name();
  inline void set_allocated_last_name(::std::string* last_name);

  // required string phone_number = 3;
  inline bool has_phone_number() const;
  inline void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 3;
  inline const ::std::string& phone_number() const;
  inline void set_phone_number(const ::std::string& value);
  inline void set_phone_number(const char* value);
  inline void set_phone_number(const char* value, size_t size);
  inline ::std::string* mutable_phone_number();
  inline ::std::string* release_phone_number();
  inline void set_allocated_phone_number(::std::string* phone_number);

  // required string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required bytes photo = 5;
  inline bool has_photo() const;
  inline void clear_photo();
  static const int kPhotoFieldNumber = 5;
  inline const ::std::string& photo() const;
  inline void set_photo(const ::std::string& value);
  inline void set_photo(const char* value);
  inline void set_photo(const void* value, size_t size);
  inline ::std::string* mutable_photo();
  inline ::std::string* release_photo();
  inline void set_allocated_photo(::std::string* photo);

  // optional string user_id = 6;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 6;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // repeated string phone_numbers = 7;
  inline int phone_numbers_size() const;
  inline void clear_phone_numbers();
  static const int kPhoneNumbersFieldNumber = 7;
  inline const ::std::string& phone_numbers(int index) const;
  inline ::std::string* mutable_phone_numbers(int index);
  inline void set_phone_numbers(int index, const ::std::string& value);
  inline void set_phone_numbers(int index, const char* value);
  inline void set_phone_numbers(int index, const char* value, size_t size);
  inline ::std::string* add_phone_numbers();
  inline void add_phone_numbers(const ::std::string& value);
  inline void add_phone_numbers(const char* value);
  inline void add_phone_numbers(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& phone_numbers() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_phone_numbers();

  // repeated .protobuffer.FriendDef friends = 8;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 8;
  inline const ::protobuffer::FriendDef& friends(int index) const;
  inline ::protobuffer::FriendDef* mutable_friends(int index);
  inline ::protobuffer::FriendDef* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuffer::FriendDef >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuffer::FriendDef >*
      mutable_friends();

  // @@protoc_insertion_point(class_scope:protobuffer.RegistrationPack)
 private:
  inline void set_has_first_name();
  inline void clear_has_first_name();
  inline void set_has_last_name();
  inline void clear_has_last_name();
  inline void set_has_phone_number();
  inline void clear_has_phone_number();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_photo();
  inline void clear_has_photo();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::std::string* first_name_;
  ::std::string* last_name_;
  ::std::string* phone_number_;
  ::std::string* email_;
  ::std::string* photo_;
  ::std::string* user_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> phone_numbers_;
  ::google::protobuf::RepeatedPtrField< ::protobuffer::FriendDef > friends_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static RegistrationPack* default_instance_;
};
// -------------------------------------------------------------------

class GroupRegistration : public ::google::protobuf::MessageLite {
 public:
  GroupRegistration();
  virtual ~GroupRegistration();

  GroupRegistration(const GroupRegistration& from);

  inline GroupRegistration& operator=(const GroupRegistration& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupRegistration& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupRegistration* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupRegistration* other);

  // implements Message ----------------------------------------------

  GroupRegistration* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupRegistration& from);
  void MergeFrom(const GroupRegistration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string creator_id = 2;
  inline bool has_creator_id() const;
  inline void clear_creator_id();
  static const int kCreatorIdFieldNumber = 2;
  inline const ::std::string& creator_id() const;
  inline void set_creator_id(const ::std::string& value);
  inline void set_creator_id(const char* value);
  inline void set_creator_id(const char* value, size_t size);
  inline ::std::string* mutable_creator_id();
  inline ::std::string* release_creator_id();
  inline void set_allocated_creator_id(::std::string* creator_id);

  // required string group_description = 3;
  inline bool has_group_description() const;
  inline void clear_group_description();
  static const int kGroupDescriptionFieldNumber = 3;
  inline const ::std::string& group_description() const;
  inline void set_group_description(const ::std::string& value);
  inline void set_group_description(const char* value);
  inline void set_group_description(const char* value, size_t size);
  inline ::std::string* mutable_group_description();
  inline ::std::string* release_group_description();
  inline void set_allocated_group_description(::std::string* group_description);

  // required bytes group_photo = 4;
  inline bool has_group_photo() const;
  inline void clear_group_photo();
  static const int kGroupPhotoFieldNumber = 4;
  inline const ::std::string& group_photo() const;
  inline void set_group_photo(const ::std::string& value);
  inline void set_group_photo(const char* value);
  inline void set_group_photo(const void* value, size_t size);
  inline ::std::string* mutable_group_photo();
  inline ::std::string* release_group_photo();
  inline void set_allocated_group_photo(::std::string* group_photo);

  // optional string group_id = 5;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 5;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:protobuffer.GroupRegistration)
 private:
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_creator_id();
  inline void clear_has_creator_id();
  inline void set_has_group_description();
  inline void clear_has_group_description();
  inline void set_has_group_photo();
  inline void clear_has_group_photo();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string* group_name_;
  ::std::string* creator_id_;
  ::std::string* group_description_;
  ::std::string* group_photo_;
  ::std::string* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static GroupRegistration* default_instance_;
};
// -------------------------------------------------------------------

class GroupDef : public ::google::protobuf::MessageLite {
 public:
  GroupDef();
  virtual ~GroupDef();

  GroupDef(const GroupDef& from);

  inline GroupDef& operator=(const GroupDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const GroupDef& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupDef* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupDef* other);

  // implements Message ----------------------------------------------

  GroupDef* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupDef& from);
  void MergeFrom(const GroupDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string group_name = 1;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional .protobuffer.FriendDef group_creator = 2;
  inline bool has_group_creator() const;
  inline void clear_group_creator();
  static const int kGroupCreatorFieldNumber = 2;
  inline const ::protobuffer::FriendDef& group_creator() const;
  inline ::protobuffer::FriendDef* mutable_group_creator();
  inline ::protobuffer::FriendDef* release_group_creator();
  inline void set_allocated_group_creator(::protobuffer::FriendDef* group_creator);

  // optional string group_description = 3;
  inline bool has_group_description() const;
  inline void clear_group_description();
  static const int kGroupDescriptionFieldNumber = 3;
  inline const ::std::string& group_description() const;
  inline void set_group_description(const ::std::string& value);
  inline void set_group_description(const char* value);
  inline void set_group_description(const char* value, size_t size);
  inline ::std::string* mutable_group_description();
  inline ::std::string* release_group_description();
  inline void set_allocated_group_description(::std::string* group_description);

  // optional string group_photo_uri = 4;
  inline bool has_group_photo_uri() const;
  inline void clear_group_photo_uri();
  static const int kGroupPhotoUriFieldNumber = 4;
  inline const ::std::string& group_photo_uri() const;
  inline void set_group_photo_uri(const ::std::string& value);
  inline void set_group_photo_uri(const char* value);
  inline void set_group_photo_uri(const char* value, size_t size);
  inline ::std::string* mutable_group_photo_uri();
  inline ::std::string* release_group_photo_uri();
  inline void set_allocated_group_photo_uri(::std::string* group_photo_uri);

  // optional string group_id = 5;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 5;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // @@protoc_insertion_point(class_scope:protobuffer.GroupDef)
 private:
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_creator();
  inline void clear_has_group_creator();
  inline void set_has_group_description();
  inline void clear_has_group_description();
  inline void set_has_group_photo_uri();
  inline void clear_has_group_photo_uri();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::std::string* group_name_;
  ::protobuffer::FriendDef* group_creator_;
  ::std::string* group_description_;
  ::std::string* group_photo_uri_;
  ::std::string* group_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static GroupDef* default_instance_;
};
// -------------------------------------------------------------------

class Attachment : public ::google::protobuf::MessageLite {
 public:
  Attachment();
  virtual ~Attachment();

  Attachment(const Attachment& from);

  inline Attachment& operator=(const Attachment& from) {
    CopyFrom(from);
    return *this;
  }

  static const Attachment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Attachment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Attachment* other);

  // implements Message ----------------------------------------------

  Attachment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Attachment& from);
  void MergeFrom(const Attachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string server_file_path = 2;
  inline bool has_server_file_path() const;
  inline void clear_server_file_path();
  static const int kServerFilePathFieldNumber = 2;
  inline const ::std::string& server_file_path() const;
  inline void set_server_file_path(const ::std::string& value);
  inline void set_server_file_path(const char* value);
  inline void set_server_file_path(const char* value, size_t size);
  inline ::std::string* mutable_server_file_path();
  inline ::std::string* release_server_file_path();
  inline void set_allocated_server_file_path(::std::string* server_file_path);

  // optional float file_size = 3;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  inline float file_size() const;
  inline void set_file_size(float value);

  // optional string home_path = 4;
  inline bool has_home_path() const;
  inline void clear_home_path();
  static const int kHomePathFieldNumber = 4;
  inline const ::std::string& home_path() const;
  inline void set_home_path(const ::std::string& value);
  inline void set_home_path(const char* value);
  inline void set_home_path(const char* value, size_t size);
  inline ::std::string* mutable_home_path();
  inline ::std::string* release_home_path();
  inline void set_allocated_home_path(::std::string* home_path);

  // @@protoc_insertion_point(class_scope:protobuffer.Attachment)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_server_file_path();
  inline void clear_has_server_file_path();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_home_path();
  inline void clear_has_home_path();

  ::std::string* name_;
  ::std::string* server_file_path_;
  ::std::string* home_path_;
  float file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static Attachment* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::MessageLite {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const Message& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Message* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Message_MessageType MessageType;
  static const MessageType GRP_MSG = Message_MessageType_GRP_MSG;
  static const MessageType FRND_MSG = Message_MessageType_FRND_MSG;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string message_data = 1;
  inline bool has_message_data() const;
  inline void clear_message_data();
  static const int kMessageDataFieldNumber = 1;
  inline const ::std::string& message_data() const;
  inline void set_message_data(const ::std::string& value);
  inline void set_message_data(const char* value);
  inline void set_message_data(const char* value, size_t size);
  inline ::std::string* mutable_message_data();
  inline ::std::string* release_message_data();
  inline void set_allocated_message_data(::std::string* message_data);

  // required string sender_id = 2;
  inline bool has_sender_id() const;
  inline void clear_sender_id();
  static const int kSenderIdFieldNumber = 2;
  inline const ::std::string& sender_id() const;
  inline void set_sender_id(const ::std::string& value);
  inline void set_sender_id(const char* value);
  inline void set_sender_id(const char* value, size_t size);
  inline ::std::string* mutable_sender_id();
  inline ::std::string* release_sender_id();
  inline void set_allocated_sender_id(::std::string* sender_id);

  // required string receiver_id = 3;
  inline bool has_receiver_id() const;
  inline void clear_receiver_id();
  static const int kReceiverIdFieldNumber = 3;
  inline const ::std::string& receiver_id() const;
  inline void set_receiver_id(const ::std::string& value);
  inline void set_receiver_id(const char* value);
  inline void set_receiver_id(const char* value, size_t size);
  inline ::std::string* mutable_receiver_id();
  inline ::std::string* release_receiver_id();
  inline void set_allocated_receiver_id(::std::string* receiver_id);

  // required .protobuffer.Message.MessageType messageType = 4;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 4;
  inline ::protobuffer::Message_MessageType messagetype() const;
  inline void set_messagetype(::protobuffer::Message_MessageType value);

  // repeated .protobuffer.Attachment attachments = 5;
  inline int attachments_size() const;
  inline void clear_attachments();
  static const int kAttachmentsFieldNumber = 5;
  inline const ::protobuffer::Attachment& attachments(int index) const;
  inline ::protobuffer::Attachment* mutable_attachments(int index);
  inline ::protobuffer::Attachment* add_attachments();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuffer::Attachment >&
      attachments() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuffer::Attachment >*
      mutable_attachments();

  // @@protoc_insertion_point(class_scope:protobuffer.Message)
 private:
  inline void set_has_message_data();
  inline void clear_has_message_data();
  inline void set_has_sender_id();
  inline void clear_has_sender_id();
  inline void set_has_receiver_id();
  inline void clear_has_receiver_id();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();

  ::std::string* message_data_;
  ::std::string* sender_id_;
  ::std::string* receiver_id_;
  ::google::protobuf::RepeatedPtrField< ::protobuffer::Attachment > attachments_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class InvitationOut : public ::google::protobuf::MessageLite {
 public:
  InvitationOut();
  virtual ~InvitationOut();

  InvitationOut(const InvitationOut& from);

  inline InvitationOut& operator=(const InvitationOut& from) {
    CopyFrom(from);
    return *this;
  }

  static const InvitationOut& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InvitationOut* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InvitationOut* other);

  // implements Message ----------------------------------------------

  InvitationOut* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InvitationOut& from);
  void MergeFrom(const InvitationOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender_id = 1;
  inline bool has_sender_id() const;
  inline void clear_sender_id();
  static const int kSenderIdFieldNumber = 1;
  inline const ::std::string& sender_id() const;
  inline void set_sender_id(const ::std::string& value);
  inline void set_sender_id(const char* value);
  inline void set_sender_id(const char* value, size_t size);
  inline ::std::string* mutable_sender_id();
  inline ::std::string* release_sender_id();
  inline void set_allocated_sender_id(::std::string* sender_id);

  // required string group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // optional string personal_message = 3;
  inline bool has_personal_message() const;
  inline void clear_personal_message();
  static const int kPersonalMessageFieldNumber = 3;
  inline const ::std::string& personal_message() const;
  inline void set_personal_message(const ::std::string& value);
  inline void set_personal_message(const char* value);
  inline void set_personal_message(const char* value, size_t size);
  inline ::std::string* mutable_personal_message();
  inline ::std::string* release_personal_message();
  inline void set_allocated_personal_message(::std::string* personal_message);

  // repeated string unique_ids = 4;
  inline int unique_ids_size() const;
  inline void clear_unique_ids();
  static const int kUniqueIdsFieldNumber = 4;
  inline const ::std::string& unique_ids(int index) const;
  inline ::std::string* mutable_unique_ids(int index);
  inline void set_unique_ids(int index, const ::std::string& value);
  inline void set_unique_ids(int index, const char* value);
  inline void set_unique_ids(int index, const char* value, size_t size);
  inline ::std::string* add_unique_ids();
  inline void add_unique_ids(const ::std::string& value);
  inline void add_unique_ids(const char* value);
  inline void add_unique_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unique_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unique_ids();

  // @@protoc_insertion_point(class_scope:protobuffer.InvitationOut)
 private:
  inline void set_has_sender_id();
  inline void clear_has_sender_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_personal_message();
  inline void clear_has_personal_message();

  ::std::string* sender_id_;
  ::std::string* group_id_;
  ::std::string* personal_message_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unique_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static InvitationOut* default_instance_;
};
// -------------------------------------------------------------------

class InvitationDef : public ::google::protobuf::MessageLite {
 public:
  InvitationDef();
  virtual ~InvitationDef();

  InvitationDef(const InvitationDef& from);

  inline InvitationDef& operator=(const InvitationDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const InvitationDef& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InvitationDef* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InvitationDef* other);

  // implements Message ----------------------------------------------

  InvitationDef* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InvitationDef& from);
  void MergeFrom(const InvitationDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protobuffer.GroupDef group = 1;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::protobuffer::GroupDef& group() const;
  inline ::protobuffer::GroupDef* mutable_group();
  inline ::protobuffer::GroupDef* release_group();
  inline void set_allocated_group(::protobuffer::GroupDef* group);

  // optional string personal_message = 2;
  inline bool has_personal_message() const;
  inline void clear_personal_message();
  static const int kPersonalMessageFieldNumber = 2;
  inline const ::std::string& personal_message() const;
  inline void set_personal_message(const ::std::string& value);
  inline void set_personal_message(const char* value);
  inline void set_personal_message(const char* value, size_t size);
  inline ::std::string* mutable_personal_message();
  inline ::std::string* release_personal_message();
  inline void set_allocated_personal_message(::std::string* personal_message);

  // required string unique_id = 3;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 3;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  inline void set_allocated_unique_id(::std::string* unique_id);

  // @@protoc_insertion_point(class_scope:protobuffer.InvitationDef)
 private:
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_personal_message();
  inline void clear_has_personal_message();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();

  ::protobuffer::GroupDef* group_;
  ::std::string* personal_message_;
  ::std::string* unique_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_chat_5fmonk_2eproto();
  #endif
  friend void protobuf_AssignDesc_chat_5fmonk_2eproto();
  friend void protobuf_ShutdownFile_chat_5fmonk_2eproto();

  void InitAsDefaultInstance();
  static InvitationDef* default_instance_;
};
// ===================================================================


// ===================================================================

// FriendDef

// optional string first_name = 1;
inline bool FriendDef::has_first_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendDef::set_has_first_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendDef::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendDef::clear_first_name() {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    first_name_->clear();
  }
  clear_has_first_name();
}
inline const ::std::string& FriendDef::first_name() const {
  return *first_name_;
}
inline void FriendDef::set_first_name(const ::std::string& value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void FriendDef::set_first_name(const char* value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void FriendDef::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendDef::mutable_first_name() {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  return first_name_;
}
inline ::std::string* FriendDef::release_first_name() {
  clear_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_name_;
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendDef::set_allocated_first_name(::std::string* first_name) {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    delete first_name_;
  }
  if (first_name) {
    set_has_first_name();
    first_name_ = first_name;
  } else {
    clear_has_first_name();
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string last_name = 2;
inline bool FriendDef::has_last_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendDef::set_has_last_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendDef::clear_has_last_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendDef::clear_last_name() {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    last_name_->clear();
  }
  clear_has_last_name();
}
inline const ::std::string& FriendDef::last_name() const {
  return *last_name_;
}
inline void FriendDef::set_last_name(const ::std::string& value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void FriendDef::set_last_name(const char* value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void FriendDef::set_last_name(const char* value, size_t size) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendDef::mutable_last_name() {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  return last_name_;
}
inline ::std::string* FriendDef::release_last_name() {
  clear_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_name_;
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendDef::set_allocated_last_name(::std::string* last_name) {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    delete last_name_;
  }
  if (last_name) {
    set_has_last_name();
    last_name_ = last_name;
  } else {
    clear_has_last_name();
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone_number = 3;
inline bool FriendDef::has_phone_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendDef::set_has_phone_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendDef::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendDef::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& FriendDef::phone_number() const {
  return *phone_number_;
}
inline void FriendDef::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void FriendDef::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void FriendDef::set_phone_number(const char* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendDef::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  return phone_number_;
}
inline ::std::string* FriendDef::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendDef::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool FriendDef::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendDef::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendDef::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendDef::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& FriendDef::email() const {
  return *email_;
}
inline void FriendDef::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void FriendDef::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void FriendDef::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendDef::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* FriendDef::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendDef::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string friend_id = 5;
inline bool FriendDef::has_friend_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendDef::set_has_friend_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendDef::clear_has_friend_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendDef::clear_friend_id() {
  if (friend_id_ != &::google::protobuf::internal::kEmptyString) {
    friend_id_->clear();
  }
  clear_has_friend_id();
}
inline const ::std::string& FriendDef::friend_id() const {
  return *friend_id_;
}
inline void FriendDef::set_friend_id(const ::std::string& value) {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  friend_id_->assign(value);
}
inline void FriendDef::set_friend_id(const char* value) {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  friend_id_->assign(value);
}
inline void FriendDef::set_friend_id(const char* value, size_t size) {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  friend_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendDef::mutable_friend_id() {
  set_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_id_ = new ::std::string;
  }
  return friend_id_;
}
inline ::std::string* FriendDef::release_friend_id() {
  clear_has_friend_id();
  if (friend_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_id_;
    friend_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendDef::set_allocated_friend_id(::std::string* friend_id) {
  if (friend_id_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_id_;
  }
  if (friend_id) {
    set_has_friend_id();
    friend_id_ = friend_id;
  } else {
    clear_has_friend_id();
    friend_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string photo_uri = 6;
inline bool FriendDef::has_photo_uri() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FriendDef::set_has_photo_uri() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FriendDef::clear_has_photo_uri() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FriendDef::clear_photo_uri() {
  if (photo_uri_ != &::google::protobuf::internal::kEmptyString) {
    photo_uri_->clear();
  }
  clear_has_photo_uri();
}
inline const ::std::string& FriendDef::photo_uri() const {
  return *photo_uri_;
}
inline void FriendDef::set_photo_uri(const ::std::string& value) {
  set_has_photo_uri();
  if (photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    photo_uri_ = new ::std::string;
  }
  photo_uri_->assign(value);
}
inline void FriendDef::set_photo_uri(const char* value) {
  set_has_photo_uri();
  if (photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    photo_uri_ = new ::std::string;
  }
  photo_uri_->assign(value);
}
inline void FriendDef::set_photo_uri(const char* value, size_t size) {
  set_has_photo_uri();
  if (photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    photo_uri_ = new ::std::string;
  }
  photo_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendDef::mutable_photo_uri() {
  set_has_photo_uri();
  if (photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    photo_uri_ = new ::std::string;
  }
  return photo_uri_;
}
inline ::std::string* FriendDef::release_photo_uri() {
  clear_has_photo_uri();
  if (photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = photo_uri_;
    photo_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendDef::set_allocated_photo_uri(::std::string* photo_uri) {
  if (photo_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete photo_uri_;
  }
  if (photo_uri) {
    set_has_photo_uri();
    photo_uri_ = photo_uri;
  } else {
    clear_has_photo_uri();
    photo_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegistrationPack

// required string first_name = 1;
inline bool RegistrationPack::has_first_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistrationPack::set_has_first_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistrationPack::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistrationPack::clear_first_name() {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    first_name_->clear();
  }
  clear_has_first_name();
}
inline const ::std::string& RegistrationPack::first_name() const {
  return *first_name_;
}
inline void RegistrationPack::set_first_name(const ::std::string& value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void RegistrationPack::set_first_name(const char* value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void RegistrationPack::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::mutable_first_name() {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  return first_name_;
}
inline ::std::string* RegistrationPack::release_first_name() {
  clear_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_name_;
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistrationPack::set_allocated_first_name(::std::string* first_name) {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    delete first_name_;
  }
  if (first_name) {
    set_has_first_name();
    first_name_ = first_name;
  } else {
    clear_has_first_name();
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string last_name = 2;
inline bool RegistrationPack::has_last_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistrationPack::set_has_last_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistrationPack::clear_has_last_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistrationPack::clear_last_name() {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    last_name_->clear();
  }
  clear_has_last_name();
}
inline const ::std::string& RegistrationPack::last_name() const {
  return *last_name_;
}
inline void RegistrationPack::set_last_name(const ::std::string& value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void RegistrationPack::set_last_name(const char* value) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(value);
}
inline void RegistrationPack::set_last_name(const char* value, size_t size) {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  last_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::mutable_last_name() {
  set_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    last_name_ = new ::std::string;
  }
  return last_name_;
}
inline ::std::string* RegistrationPack::release_last_name() {
  clear_has_last_name();
  if (last_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_name_;
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistrationPack::set_allocated_last_name(::std::string* last_name) {
  if (last_name_ != &::google::protobuf::internal::kEmptyString) {
    delete last_name_;
  }
  if (last_name) {
    set_has_last_name();
    last_name_ = last_name;
  } else {
    clear_has_last_name();
    last_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string phone_number = 3;
inline bool RegistrationPack::has_phone_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistrationPack::set_has_phone_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistrationPack::clear_has_phone_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistrationPack::clear_phone_number() {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    phone_number_->clear();
  }
  clear_has_phone_number();
}
inline const ::std::string& RegistrationPack::phone_number() const {
  return *phone_number_;
}
inline void RegistrationPack::set_phone_number(const ::std::string& value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void RegistrationPack::set_phone_number(const char* value) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(value);
}
inline void RegistrationPack::set_phone_number(const char* value, size_t size) {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  phone_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::mutable_phone_number() {
  set_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    phone_number_ = new ::std::string;
  }
  return phone_number_;
}
inline ::std::string* RegistrationPack::release_phone_number() {
  clear_has_phone_number();
  if (phone_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_number_;
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistrationPack::set_allocated_phone_number(::std::string* phone_number) {
  if (phone_number_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_number_;
  }
  if (phone_number) {
    set_has_phone_number();
    phone_number_ = phone_number;
  } else {
    clear_has_phone_number();
    phone_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string email = 4;
inline bool RegistrationPack::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegistrationPack::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegistrationPack::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegistrationPack::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& RegistrationPack::email() const {
  return *email_;
}
inline void RegistrationPack::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegistrationPack::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void RegistrationPack::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* RegistrationPack::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistrationPack::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes photo = 5;
inline bool RegistrationPack::has_photo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegistrationPack::set_has_photo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegistrationPack::clear_has_photo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegistrationPack::clear_photo() {
  if (photo_ != &::google::protobuf::internal::kEmptyString) {
    photo_->clear();
  }
  clear_has_photo();
}
inline const ::std::string& RegistrationPack::photo() const {
  return *photo_;
}
inline void RegistrationPack::set_photo(const ::std::string& value) {
  set_has_photo();
  if (photo_ == &::google::protobuf::internal::kEmptyString) {
    photo_ = new ::std::string;
  }
  photo_->assign(value);
}
inline void RegistrationPack::set_photo(const char* value) {
  set_has_photo();
  if (photo_ == &::google::protobuf::internal::kEmptyString) {
    photo_ = new ::std::string;
  }
  photo_->assign(value);
}
inline void RegistrationPack::set_photo(const void* value, size_t size) {
  set_has_photo();
  if (photo_ == &::google::protobuf::internal::kEmptyString) {
    photo_ = new ::std::string;
  }
  photo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::mutable_photo() {
  set_has_photo();
  if (photo_ == &::google::protobuf::internal::kEmptyString) {
    photo_ = new ::std::string;
  }
  return photo_;
}
inline ::std::string* RegistrationPack::release_photo() {
  clear_has_photo();
  if (photo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = photo_;
    photo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistrationPack::set_allocated_photo(::std::string* photo) {
  if (photo_ != &::google::protobuf::internal::kEmptyString) {
    delete photo_;
  }
  if (photo) {
    set_has_photo();
    photo_ = photo;
  } else {
    clear_has_photo();
    photo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_id = 6;
inline bool RegistrationPack::has_user_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegistrationPack::set_has_user_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegistrationPack::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegistrationPack::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& RegistrationPack::user_id() const {
  return *user_id_;
}
inline void RegistrationPack::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void RegistrationPack::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void RegistrationPack::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* RegistrationPack::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistrationPack::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string phone_numbers = 7;
inline int RegistrationPack::phone_numbers_size() const {
  return phone_numbers_.size();
}
inline void RegistrationPack::clear_phone_numbers() {
  phone_numbers_.Clear();
}
inline const ::std::string& RegistrationPack::phone_numbers(int index) const {
  return phone_numbers_.Get(index);
}
inline ::std::string* RegistrationPack::mutable_phone_numbers(int index) {
  return phone_numbers_.Mutable(index);
}
inline void RegistrationPack::set_phone_numbers(int index, const ::std::string& value) {
  phone_numbers_.Mutable(index)->assign(value);
}
inline void RegistrationPack::set_phone_numbers(int index, const char* value) {
  phone_numbers_.Mutable(index)->assign(value);
}
inline void RegistrationPack::set_phone_numbers(int index, const char* value, size_t size) {
  phone_numbers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistrationPack::add_phone_numbers() {
  return phone_numbers_.Add();
}
inline void RegistrationPack::add_phone_numbers(const ::std::string& value) {
  phone_numbers_.Add()->assign(value);
}
inline void RegistrationPack::add_phone_numbers(const char* value) {
  phone_numbers_.Add()->assign(value);
}
inline void RegistrationPack::add_phone_numbers(const char* value, size_t size) {
  phone_numbers_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegistrationPack::phone_numbers() const {
  return phone_numbers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegistrationPack::mutable_phone_numbers() {
  return &phone_numbers_;
}

// repeated .protobuffer.FriendDef friends = 8;
inline int RegistrationPack::friends_size() const {
  return friends_.size();
}
inline void RegistrationPack::clear_friends() {
  friends_.Clear();
}
inline const ::protobuffer::FriendDef& RegistrationPack::friends(int index) const {
  return friends_.Get(index);
}
inline ::protobuffer::FriendDef* RegistrationPack::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::protobuffer::FriendDef* RegistrationPack::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuffer::FriendDef >&
RegistrationPack::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuffer::FriendDef >*
RegistrationPack::mutable_friends() {
  return &friends_;
}

// -------------------------------------------------------------------

// GroupRegistration

// required string group_name = 1;
inline bool GroupRegistration::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupRegistration::set_has_group_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupRegistration::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupRegistration::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupRegistration::group_name() const {
  return *group_name_;
}
inline void GroupRegistration::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupRegistration::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupRegistration::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupRegistration::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* GroupRegistration::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupRegistration::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string creator_id = 2;
inline bool GroupRegistration::has_creator_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupRegistration::set_has_creator_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupRegistration::clear_has_creator_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupRegistration::clear_creator_id() {
  if (creator_id_ != &::google::protobuf::internal::kEmptyString) {
    creator_id_->clear();
  }
  clear_has_creator_id();
}
inline const ::std::string& GroupRegistration::creator_id() const {
  return *creator_id_;
}
inline void GroupRegistration::set_creator_id(const ::std::string& value) {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  creator_id_->assign(value);
}
inline void GroupRegistration::set_creator_id(const char* value) {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  creator_id_->assign(value);
}
inline void GroupRegistration::set_creator_id(const char* value, size_t size) {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  creator_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupRegistration::mutable_creator_id() {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  return creator_id_;
}
inline ::std::string* GroupRegistration::release_creator_id() {
  clear_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_id_;
    creator_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupRegistration::set_allocated_creator_id(::std::string* creator_id) {
  if (creator_id_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_id_;
  }
  if (creator_id) {
    set_has_creator_id();
    creator_id_ = creator_id;
  } else {
    clear_has_creator_id();
    creator_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string group_description = 3;
inline bool GroupRegistration::has_group_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupRegistration::set_has_group_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupRegistration::clear_has_group_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupRegistration::clear_group_description() {
  if (group_description_ != &::google::protobuf::internal::kEmptyString) {
    group_description_->clear();
  }
  clear_has_group_description();
}
inline const ::std::string& GroupRegistration::group_description() const {
  return *group_description_;
}
inline void GroupRegistration::set_group_description(const ::std::string& value) {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  group_description_->assign(value);
}
inline void GroupRegistration::set_group_description(const char* value) {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  group_description_->assign(value);
}
inline void GroupRegistration::set_group_description(const char* value, size_t size) {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  group_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupRegistration::mutable_group_description() {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  return group_description_;
}
inline ::std::string* GroupRegistration::release_group_description() {
  clear_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_description_;
    group_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupRegistration::set_allocated_group_description(::std::string* group_description) {
  if (group_description_ != &::google::protobuf::internal::kEmptyString) {
    delete group_description_;
  }
  if (group_description) {
    set_has_group_description();
    group_description_ = group_description;
  } else {
    clear_has_group_description();
    group_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes group_photo = 4;
inline bool GroupRegistration::has_group_photo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupRegistration::set_has_group_photo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupRegistration::clear_has_group_photo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupRegistration::clear_group_photo() {
  if (group_photo_ != &::google::protobuf::internal::kEmptyString) {
    group_photo_->clear();
  }
  clear_has_group_photo();
}
inline const ::std::string& GroupRegistration::group_photo() const {
  return *group_photo_;
}
inline void GroupRegistration::set_group_photo(const ::std::string& value) {
  set_has_group_photo();
  if (group_photo_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_ = new ::std::string;
  }
  group_photo_->assign(value);
}
inline void GroupRegistration::set_group_photo(const char* value) {
  set_has_group_photo();
  if (group_photo_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_ = new ::std::string;
  }
  group_photo_->assign(value);
}
inline void GroupRegistration::set_group_photo(const void* value, size_t size) {
  set_has_group_photo();
  if (group_photo_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_ = new ::std::string;
  }
  group_photo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupRegistration::mutable_group_photo() {
  set_has_group_photo();
  if (group_photo_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_ = new ::std::string;
  }
  return group_photo_;
}
inline ::std::string* GroupRegistration::release_group_photo() {
  clear_has_group_photo();
  if (group_photo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_photo_;
    group_photo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupRegistration::set_allocated_group_photo(::std::string* group_photo) {
  if (group_photo_ != &::google::protobuf::internal::kEmptyString) {
    delete group_photo_;
  }
  if (group_photo) {
    set_has_group_photo();
    group_photo_ = group_photo;
  } else {
    clear_has_group_photo();
    group_photo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_id = 5;
inline bool GroupRegistration::has_group_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupRegistration::set_has_group_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupRegistration::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupRegistration::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& GroupRegistration::group_id() const {
  return *group_id_;
}
inline void GroupRegistration::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void GroupRegistration::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void GroupRegistration::set_group_id(const char* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupRegistration::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}
inline ::std::string* GroupRegistration::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupRegistration::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupDef

// required string group_name = 1;
inline bool GroupDef::has_group_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupDef::set_has_group_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupDef::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupDef::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupDef::group_name() const {
  return *group_name_;
}
inline void GroupDef::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupDef::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void GroupDef::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupDef::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* GroupDef::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupDef::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protobuffer.FriendDef group_creator = 2;
inline bool GroupDef::has_group_creator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupDef::set_has_group_creator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupDef::clear_has_group_creator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupDef::clear_group_creator() {
  if (group_creator_ != NULL) group_creator_->::protobuffer::FriendDef::Clear();
  clear_has_group_creator();
}
inline const ::protobuffer::FriendDef& GroupDef::group_creator() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_creator_ != NULL ? *group_creator_ : *default_instance().group_creator_;
#else
  return group_creator_ != NULL ? *group_creator_ : *default_instance_->group_creator_;
#endif
}
inline ::protobuffer::FriendDef* GroupDef::mutable_group_creator() {
  set_has_group_creator();
  if (group_creator_ == NULL) group_creator_ = new ::protobuffer::FriendDef;
  return group_creator_;
}
inline ::protobuffer::FriendDef* GroupDef::release_group_creator() {
  clear_has_group_creator();
  ::protobuffer::FriendDef* temp = group_creator_;
  group_creator_ = NULL;
  return temp;
}
inline void GroupDef::set_allocated_group_creator(::protobuffer::FriendDef* group_creator) {
  delete group_creator_;
  group_creator_ = group_creator;
  if (group_creator) {
    set_has_group_creator();
  } else {
    clear_has_group_creator();
  }
}

// optional string group_description = 3;
inline bool GroupDef::has_group_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupDef::set_has_group_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupDef::clear_has_group_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupDef::clear_group_description() {
  if (group_description_ != &::google::protobuf::internal::kEmptyString) {
    group_description_->clear();
  }
  clear_has_group_description();
}
inline const ::std::string& GroupDef::group_description() const {
  return *group_description_;
}
inline void GroupDef::set_group_description(const ::std::string& value) {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  group_description_->assign(value);
}
inline void GroupDef::set_group_description(const char* value) {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  group_description_->assign(value);
}
inline void GroupDef::set_group_description(const char* value, size_t size) {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  group_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupDef::mutable_group_description() {
  set_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    group_description_ = new ::std::string;
  }
  return group_description_;
}
inline ::std::string* GroupDef::release_group_description() {
  clear_has_group_description();
  if (group_description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_description_;
    group_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupDef::set_allocated_group_description(::std::string* group_description) {
  if (group_description_ != &::google::protobuf::internal::kEmptyString) {
    delete group_description_;
  }
  if (group_description) {
    set_has_group_description();
    group_description_ = group_description;
  } else {
    clear_has_group_description();
    group_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_photo_uri = 4;
inline bool GroupDef::has_group_photo_uri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupDef::set_has_group_photo_uri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupDef::clear_has_group_photo_uri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupDef::clear_group_photo_uri() {
  if (group_photo_uri_ != &::google::protobuf::internal::kEmptyString) {
    group_photo_uri_->clear();
  }
  clear_has_group_photo_uri();
}
inline const ::std::string& GroupDef::group_photo_uri() const {
  return *group_photo_uri_;
}
inline void GroupDef::set_group_photo_uri(const ::std::string& value) {
  set_has_group_photo_uri();
  if (group_photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_uri_ = new ::std::string;
  }
  group_photo_uri_->assign(value);
}
inline void GroupDef::set_group_photo_uri(const char* value) {
  set_has_group_photo_uri();
  if (group_photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_uri_ = new ::std::string;
  }
  group_photo_uri_->assign(value);
}
inline void GroupDef::set_group_photo_uri(const char* value, size_t size) {
  set_has_group_photo_uri();
  if (group_photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_uri_ = new ::std::string;
  }
  group_photo_uri_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupDef::mutable_group_photo_uri() {
  set_has_group_photo_uri();
  if (group_photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    group_photo_uri_ = new ::std::string;
  }
  return group_photo_uri_;
}
inline ::std::string* GroupDef::release_group_photo_uri() {
  clear_has_group_photo_uri();
  if (group_photo_uri_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_photo_uri_;
    group_photo_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupDef::set_allocated_group_photo_uri(::std::string* group_photo_uri) {
  if (group_photo_uri_ != &::google::protobuf::internal::kEmptyString) {
    delete group_photo_uri_;
  }
  if (group_photo_uri) {
    set_has_group_photo_uri();
    group_photo_uri_ = group_photo_uri;
  } else {
    clear_has_group_photo_uri();
    group_photo_uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group_id = 5;
inline bool GroupDef::has_group_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupDef::set_has_group_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupDef::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupDef::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& GroupDef::group_id() const {
  return *group_id_;
}
inline void GroupDef::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void GroupDef::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void GroupDef::set_group_id(const char* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupDef::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}
inline ::std::string* GroupDef::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupDef::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Attachment

// optional string name = 1;
inline bool Attachment::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attachment::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attachment::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attachment::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Attachment::name() const {
  return *name_;
}
inline void Attachment::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attachment::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Attachment::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attachment::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Attachment::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attachment::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string server_file_path = 2;
inline bool Attachment::has_server_file_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attachment::set_has_server_file_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attachment::clear_has_server_file_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attachment::clear_server_file_path() {
  if (server_file_path_ != &::google::protobuf::internal::kEmptyString) {
    server_file_path_->clear();
  }
  clear_has_server_file_path();
}
inline const ::std::string& Attachment::server_file_path() const {
  return *server_file_path_;
}
inline void Attachment::set_server_file_path(const ::std::string& value) {
  set_has_server_file_path();
  if (server_file_path_ == &::google::protobuf::internal::kEmptyString) {
    server_file_path_ = new ::std::string;
  }
  server_file_path_->assign(value);
}
inline void Attachment::set_server_file_path(const char* value) {
  set_has_server_file_path();
  if (server_file_path_ == &::google::protobuf::internal::kEmptyString) {
    server_file_path_ = new ::std::string;
  }
  server_file_path_->assign(value);
}
inline void Attachment::set_server_file_path(const char* value, size_t size) {
  set_has_server_file_path();
  if (server_file_path_ == &::google::protobuf::internal::kEmptyString) {
    server_file_path_ = new ::std::string;
  }
  server_file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attachment::mutable_server_file_path() {
  set_has_server_file_path();
  if (server_file_path_ == &::google::protobuf::internal::kEmptyString) {
    server_file_path_ = new ::std::string;
  }
  return server_file_path_;
}
inline ::std::string* Attachment::release_server_file_path() {
  clear_has_server_file_path();
  if (server_file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_file_path_;
    server_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attachment::set_allocated_server_file_path(::std::string* server_file_path) {
  if (server_file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete server_file_path_;
  }
  if (server_file_path) {
    set_has_server_file_path();
    server_file_path_ = server_file_path;
  } else {
    clear_has_server_file_path();
    server_file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float file_size = 3;
inline bool Attachment::has_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attachment::set_has_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attachment::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attachment::clear_file_size() {
  file_size_ = 0;
  clear_has_file_size();
}
inline float Attachment::file_size() const {
  return file_size_;
}
inline void Attachment::set_file_size(float value) {
  set_has_file_size();
  file_size_ = value;
}

// optional string home_path = 4;
inline bool Attachment::has_home_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attachment::set_has_home_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attachment::clear_has_home_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attachment::clear_home_path() {
  if (home_path_ != &::google::protobuf::internal::kEmptyString) {
    home_path_->clear();
  }
  clear_has_home_path();
}
inline const ::std::string& Attachment::home_path() const {
  return *home_path_;
}
inline void Attachment::set_home_path(const ::std::string& value) {
  set_has_home_path();
  if (home_path_ == &::google::protobuf::internal::kEmptyString) {
    home_path_ = new ::std::string;
  }
  home_path_->assign(value);
}
inline void Attachment::set_home_path(const char* value) {
  set_has_home_path();
  if (home_path_ == &::google::protobuf::internal::kEmptyString) {
    home_path_ = new ::std::string;
  }
  home_path_->assign(value);
}
inline void Attachment::set_home_path(const char* value, size_t size) {
  set_has_home_path();
  if (home_path_ == &::google::protobuf::internal::kEmptyString) {
    home_path_ = new ::std::string;
  }
  home_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attachment::mutable_home_path() {
  set_has_home_path();
  if (home_path_ == &::google::protobuf::internal::kEmptyString) {
    home_path_ = new ::std::string;
  }
  return home_path_;
}
inline ::std::string* Attachment::release_home_path() {
  clear_has_home_path();
  if (home_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = home_path_;
    home_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attachment::set_allocated_home_path(::std::string* home_path) {
  if (home_path_ != &::google::protobuf::internal::kEmptyString) {
    delete home_path_;
  }
  if (home_path) {
    set_has_home_path();
    home_path_ = home_path;
  } else {
    clear_has_home_path();
    home_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message

// required string message_data = 1;
inline bool Message::has_message_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_message_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_message_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_message_data() {
  if (message_data_ != &::google::protobuf::internal::kEmptyString) {
    message_data_->clear();
  }
  clear_has_message_data();
}
inline const ::std::string& Message::message_data() const {
  return *message_data_;
}
inline void Message::set_message_data(const ::std::string& value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::kEmptyString) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void Message::set_message_data(const char* value) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::kEmptyString) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(value);
}
inline void Message::set_message_data(const char* value, size_t size) {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::kEmptyString) {
    message_data_ = new ::std::string;
  }
  message_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_message_data() {
  set_has_message_data();
  if (message_data_ == &::google::protobuf::internal::kEmptyString) {
    message_data_ = new ::std::string;
  }
  return message_data_;
}
inline ::std::string* Message::release_message_data() {
  clear_has_message_data();
  if (message_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_data_;
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_message_data(::std::string* message_data) {
  if (message_data_ != &::google::protobuf::internal::kEmptyString) {
    delete message_data_;
  }
  if (message_data) {
    set_has_message_data();
    message_data_ = message_data;
  } else {
    clear_has_message_data();
    message_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sender_id = 2;
inline bool Message::has_sender_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_sender_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_sender_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_sender_id() {
  if (sender_id_ != &::google::protobuf::internal::kEmptyString) {
    sender_id_->clear();
  }
  clear_has_sender_id();
}
inline const ::std::string& Message::sender_id() const {
  return *sender_id_;
}
inline void Message::set_sender_id(const ::std::string& value) {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void Message::set_sender_id(const char* value) {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void Message::set_sender_id(const char* value, size_t size) {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_sender_id() {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  return sender_id_;
}
inline ::std::string* Message::release_sender_id() {
  clear_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_id_;
    sender_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_sender_id(::std::string* sender_id) {
  if (sender_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_id_;
  }
  if (sender_id) {
    set_has_sender_id();
    sender_id_ = sender_id;
  } else {
    clear_has_sender_id();
    sender_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string receiver_id = 3;
inline bool Message::has_receiver_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_receiver_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_receiver_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_receiver_id() {
  if (receiver_id_ != &::google::protobuf::internal::kEmptyString) {
    receiver_id_->clear();
  }
  clear_has_receiver_id();
}
inline const ::std::string& Message::receiver_id() const {
  return *receiver_id_;
}
inline void Message::set_receiver_id(const ::std::string& value) {
  set_has_receiver_id();
  if (receiver_id_ == &::google::protobuf::internal::kEmptyString) {
    receiver_id_ = new ::std::string;
  }
  receiver_id_->assign(value);
}
inline void Message::set_receiver_id(const char* value) {
  set_has_receiver_id();
  if (receiver_id_ == &::google::protobuf::internal::kEmptyString) {
    receiver_id_ = new ::std::string;
  }
  receiver_id_->assign(value);
}
inline void Message::set_receiver_id(const char* value, size_t size) {
  set_has_receiver_id();
  if (receiver_id_ == &::google::protobuf::internal::kEmptyString) {
    receiver_id_ = new ::std::string;
  }
  receiver_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_receiver_id() {
  set_has_receiver_id();
  if (receiver_id_ == &::google::protobuf::internal::kEmptyString) {
    receiver_id_ = new ::std::string;
  }
  return receiver_id_;
}
inline ::std::string* Message::release_receiver_id() {
  clear_has_receiver_id();
  if (receiver_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_id_;
    receiver_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_receiver_id(::std::string* receiver_id) {
  if (receiver_id_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_id_;
  }
  if (receiver_id) {
    set_has_receiver_id();
    receiver_id_ = receiver_id;
  } else {
    clear_has_receiver_id();
    receiver_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .protobuffer.Message.MessageType messageType = 4;
inline bool Message::has_messagetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_messagetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::protobuffer::Message_MessageType Message::messagetype() const {
  return static_cast< ::protobuffer::Message_MessageType >(messagetype_);
}
inline void Message::set_messagetype(::protobuffer::Message_MessageType value) {
  assert(::protobuffer::Message_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// repeated .protobuffer.Attachment attachments = 5;
inline int Message::attachments_size() const {
  return attachments_.size();
}
inline void Message::clear_attachments() {
  attachments_.Clear();
}
inline const ::protobuffer::Attachment& Message::attachments(int index) const {
  return attachments_.Get(index);
}
inline ::protobuffer::Attachment* Message::mutable_attachments(int index) {
  return attachments_.Mutable(index);
}
inline ::protobuffer::Attachment* Message::add_attachments() {
  return attachments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuffer::Attachment >&
Message::attachments() const {
  return attachments_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuffer::Attachment >*
Message::mutable_attachments() {
  return &attachments_;
}

// -------------------------------------------------------------------

// InvitationOut

// required string sender_id = 1;
inline bool InvitationOut::has_sender_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitationOut::set_has_sender_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitationOut::clear_has_sender_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitationOut::clear_sender_id() {
  if (sender_id_ != &::google::protobuf::internal::kEmptyString) {
    sender_id_->clear();
  }
  clear_has_sender_id();
}
inline const ::std::string& InvitationOut::sender_id() const {
  return *sender_id_;
}
inline void InvitationOut::set_sender_id(const ::std::string& value) {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void InvitationOut::set_sender_id(const char* value) {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(value);
}
inline void InvitationOut::set_sender_id(const char* value, size_t size) {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  sender_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitationOut::mutable_sender_id() {
  set_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    sender_id_ = new ::std::string;
  }
  return sender_id_;
}
inline ::std::string* InvitationOut::release_sender_id() {
  clear_has_sender_id();
  if (sender_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_id_;
    sender_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitationOut::set_allocated_sender_id(::std::string* sender_id) {
  if (sender_id_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_id_;
  }
  if (sender_id) {
    set_has_sender_id();
    sender_id_ = sender_id;
  } else {
    clear_has_sender_id();
    sender_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string group_id = 2;
inline bool InvitationOut::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitationOut::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitationOut::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitationOut::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& InvitationOut::group_id() const {
  return *group_id_;
}
inline void InvitationOut::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void InvitationOut::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void InvitationOut::set_group_id(const char* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitationOut::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}
inline ::std::string* InvitationOut::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitationOut::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string personal_message = 3;
inline bool InvitationOut::has_personal_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvitationOut::set_has_personal_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvitationOut::clear_has_personal_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvitationOut::clear_personal_message() {
  if (personal_message_ != &::google::protobuf::internal::kEmptyString) {
    personal_message_->clear();
  }
  clear_has_personal_message();
}
inline const ::std::string& InvitationOut::personal_message() const {
  return *personal_message_;
}
inline void InvitationOut::set_personal_message(const ::std::string& value) {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  personal_message_->assign(value);
}
inline void InvitationOut::set_personal_message(const char* value) {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  personal_message_->assign(value);
}
inline void InvitationOut::set_personal_message(const char* value, size_t size) {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  personal_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitationOut::mutable_personal_message() {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  return personal_message_;
}
inline ::std::string* InvitationOut::release_personal_message() {
  clear_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = personal_message_;
    personal_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitationOut::set_allocated_personal_message(::std::string* personal_message) {
  if (personal_message_ != &::google::protobuf::internal::kEmptyString) {
    delete personal_message_;
  }
  if (personal_message) {
    set_has_personal_message();
    personal_message_ = personal_message;
  } else {
    clear_has_personal_message();
    personal_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string unique_ids = 4;
inline int InvitationOut::unique_ids_size() const {
  return unique_ids_.size();
}
inline void InvitationOut::clear_unique_ids() {
  unique_ids_.Clear();
}
inline const ::std::string& InvitationOut::unique_ids(int index) const {
  return unique_ids_.Get(index);
}
inline ::std::string* InvitationOut::mutable_unique_ids(int index) {
  return unique_ids_.Mutable(index);
}
inline void InvitationOut::set_unique_ids(int index, const ::std::string& value) {
  unique_ids_.Mutable(index)->assign(value);
}
inline void InvitationOut::set_unique_ids(int index, const char* value) {
  unique_ids_.Mutable(index)->assign(value);
}
inline void InvitationOut::set_unique_ids(int index, const char* value, size_t size) {
  unique_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitationOut::add_unique_ids() {
  return unique_ids_.Add();
}
inline void InvitationOut::add_unique_ids(const ::std::string& value) {
  unique_ids_.Add()->assign(value);
}
inline void InvitationOut::add_unique_ids(const char* value) {
  unique_ids_.Add()->assign(value);
}
inline void InvitationOut::add_unique_ids(const char* value, size_t size) {
  unique_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InvitationOut::unique_ids() const {
  return unique_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InvitationOut::mutable_unique_ids() {
  return &unique_ids_;
}

// -------------------------------------------------------------------

// InvitationDef

// required .protobuffer.GroupDef group = 1;
inline bool InvitationDef::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitationDef::set_has_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitationDef::clear_has_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitationDef::clear_group() {
  if (group_ != NULL) group_->::protobuffer::GroupDef::Clear();
  clear_has_group();
}
inline const ::protobuffer::GroupDef& InvitationDef::group() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return group_ != NULL ? *group_ : *default_instance().group_;
#else
  return group_ != NULL ? *group_ : *default_instance_->group_;
#endif
}
inline ::protobuffer::GroupDef* InvitationDef::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::protobuffer::GroupDef;
  return group_;
}
inline ::protobuffer::GroupDef* InvitationDef::release_group() {
  clear_has_group();
  ::protobuffer::GroupDef* temp = group_;
  group_ = NULL;
  return temp;
}
inline void InvitationDef::set_allocated_group(::protobuffer::GroupDef* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// optional string personal_message = 2;
inline bool InvitationDef::has_personal_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitationDef::set_has_personal_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitationDef::clear_has_personal_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitationDef::clear_personal_message() {
  if (personal_message_ != &::google::protobuf::internal::kEmptyString) {
    personal_message_->clear();
  }
  clear_has_personal_message();
}
inline const ::std::string& InvitationDef::personal_message() const {
  return *personal_message_;
}
inline void InvitationDef::set_personal_message(const ::std::string& value) {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  personal_message_->assign(value);
}
inline void InvitationDef::set_personal_message(const char* value) {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  personal_message_->assign(value);
}
inline void InvitationDef::set_personal_message(const char* value, size_t size) {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  personal_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitationDef::mutable_personal_message() {
  set_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    personal_message_ = new ::std::string;
  }
  return personal_message_;
}
inline ::std::string* InvitationDef::release_personal_message() {
  clear_has_personal_message();
  if (personal_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = personal_message_;
    personal_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitationDef::set_allocated_personal_message(::std::string* personal_message) {
  if (personal_message_ != &::google::protobuf::internal::kEmptyString) {
    delete personal_message_;
  }
  if (personal_message) {
    set_has_personal_message();
    personal_message_ = personal_message;
  } else {
    clear_has_personal_message();
    personal_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string unique_id = 3;
inline bool InvitationDef::has_unique_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvitationDef::set_has_unique_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvitationDef::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvitationDef::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& InvitationDef::unique_id() const {
  return *unique_id_;
}
inline void InvitationDef::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void InvitationDef::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void InvitationDef::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvitationDef::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* InvitationDef::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvitationDef::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    delete unique_id_;
  }
  if (unique_id) {
    set_has_unique_id();
    unique_id_ = unique_id;
  } else {
    clear_has_unique_id();
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuffer

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chat_5fmonk_2eproto__INCLUDED
